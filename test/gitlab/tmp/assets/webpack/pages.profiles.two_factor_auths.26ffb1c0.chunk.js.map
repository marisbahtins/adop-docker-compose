{"version":3,"sources":["webpack:///./u2f/register.js","webpack:///./pages/profiles/two_factor_auths/index.js","webpack:///./u2f/util.js","webpack:///./u2f/error.js","webpack:////home/git/gitlab/vendor/assets/javascripts/u2f.js"],"names":["U2FRegister","container","u2fParams","_classCallCheck","this","u2fUtils","renderNotSupported","bind","renderRegistered","renderError","renderInProgress","renderSetup","renderTemplate","register","start","appId","app_id","registerRequests","register_requests","signRequests","sign_requests","templates","notSupported","setup","inProgress","error","registered","_this","importU2FLibrary","then","utils","catch","_this2","response","errorCode","U2FError","JSON","stringify","name","params","templateString","$","html","template","_","find","on","error_message","message","error_code","deviceResponse","val","document","addEventListener","twoFactorNode","querySelector","parseBoolean","dataset","twoFactorSkippable","button","concat","two_factor_skip_url","flashAlert","insertAdjacentHTML","gon","u2f","isOpera","userAgent","indexOf","canInjectU2fApi","isSupportedChrome","isChrome","match","parseInt","getChromeVersion","isSupportedOpera","getOperaVersion","isMobile","test","window","Promise","resolve","navigator","test_env","__webpack_require__","t","reject","d","__webpack_exports__","u2fFlowType","httpsDisabled","location","protocol","ErrorCodes","BAD_REQUEST","DEVICE_INELIGIBLE","js_api_version","EXTENSION_ID","MessageTypes","U2F_REGISTER_REQUEST","U2F_REGISTER_RESPONSE","U2F_SIGN_REQUEST","U2F_SIGN_RESPONSE","U2F_GET_API_VERSION_REQUEST","U2F_GET_API_VERSION_RESPONSE","OK","OTHER_ERROR","CONFIGURATION_UNSUPPORTED","TIMEOUT","U2fRequest","U2fResponse","Error","Transport","Transports","SignRequest","SignResponse","RegisterRequest","RegisterResponse","RegisteredKey","GetJsApiVersionResponse","getMessagePort","callback","chrome","runtime","msg","type","sendMessage","lastError","getIframePort_","getChromeRuntimePort_","isAndroidChrome_","getAuthenticatorPort_","isIosChrome_","getIosPort_","inArray","platform","port","connect","includeTlsChannelId","setTimeout","WrappedChromeRuntimePort_","WrappedAuthenticatorPort_","WrappedIosPort_","port_","formatSignRequest_","challenge","registeredKeys","timeoutSeconds","reqId","undefined","i","length","version","keyHandle","requestId","formatRegisterRequest_","prototype","postMessage","eventName","handler","toLowerCase","onMessage","addListener","data","console","requestId_","requestObject_","intentUrl","INTENT_URL_BASE_","encodeURIComponent","getPortType","onRequestUpdate_","messageObject","parse","responseObject","hasOwnProperty","str","url","encodeURI","replace","iframeOrigin","iframe","createElement","src","setAttribute","body","appendChild","channel","MessageChannel","ready","port1","removeEventListener","contentWindow","port2","EXTENSION_TIMEOUT_SEC","waitingForPort_","reqCounter_","callbackMap_","getPortSingleton_","shift","push","responseHandler_","cb","sign","opt_timeoutSeconds","getApiVersion","log","sendSignRequest","req","sendRegisterRequest","apiVersion"],"mappings":"oXASqBA,aACnB,SAAAA,EAAYC,EAAWC,gGAAWC,CAAAC,KAAAJ,GAChCI,KAAKC,SAAW,KAChBD,KAAKH,UAAYA,EACjBG,KAAKE,mBAAqBF,KAAKE,mBAAmBC,KAAKH,MACvDA,KAAKI,iBAAmBJ,KAAKI,iBAAiBD,KAAKH,MACnDA,KAAKK,YAAcL,KAAKK,YAAYF,KAAKH,MACzCA,KAAKM,iBAAmBN,KAAKM,iBAAiBH,KAAKH,MACnDA,KAAKO,YAAcP,KAAKO,YAAYJ,KAAKH,MACzCA,KAAKQ,eAAiBR,KAAKQ,eAAeL,KAAKH,MAC/CA,KAAKS,SAAWT,KAAKS,SAASN,KAAKH,MACnCA,KAAKU,MAAQV,KAAKU,MAAMP,KAAKH,MAC7BA,KAAKW,MAAQb,EAAUc,OACvBZ,KAAKa,iBAAmBf,EAAUgB,kBAClCd,KAAKe,aAAejB,EAAUkB,cAE9BhB,KAAKiB,WACHC,aAAc,iCACdC,MAAO,yBACPC,WAAY,+BACZC,MAAO,yBACPC,WAAY,sFAIR,IAAAC,EAAAvB,KACN,OAAOwB,cACJC,KAAK,SAAAC,GACJH,EAAKtB,SAAWyB,EAChBH,EAAKhB,gBAENoB,MAAM,kBAAMJ,EAAKrB,0DAGX,IAAA0B,EAAA5B,KACT,OAAOA,KAAKC,SAASQ,SACnBT,KAAKW,MACLX,KAAKa,iBACLb,KAAKe,aACL,SAAAc,GACE,GAAIA,EAASC,UAAW,CACtB,IAAMT,EAAQ,IAAIU,IAASF,EAASC,UAAW,YAC/C,OAAOF,EAAKvB,YAAYgB,GAE1B,OAAOO,EAAKxB,iBAAiB4B,KAAKC,UAAUJ,KAE9C,2CAIWK,EAAMC,GACnB,IAAMC,EAAiBC,IAAErC,KAAKiB,UAAUiB,IAAOI,OACzCC,EAAWC,IAAED,SAASH,GAC5B,OAAOpC,KAAKH,UAAUyC,KAAKC,EAASJ,0CAKpC,OADAnC,KAAKQ,eAAe,SACbR,KAAKH,UAAU4C,KAAK,wBAAwBC,GAAG,QAAS1C,KAAKM,6DAKpE,OADAN,KAAKQ,eAAe,cACbR,KAAKS,+CAGFY,GAKV,OAJArB,KAAKQ,eAAe,SAClBmC,cAAetB,EAAMuB,UACrBC,WAAYxB,EAAMS,YAEb9B,KAAKH,UAAU4C,KAAK,qBAAqBC,GAAG,QAAS1C,KAAKO,sDAGlDuC,GAIf,OAHA9C,KAAKQ,eAAe,cAGbR,KAAKH,UAAU4C,KAAK,uBAAuBM,IAAID,gDAItD,OAAO9C,KAAKQ,eAAe,6DCvF/BwC,SAASC,iBAAiB,mBAAoB,WAC5C,IAAMC,EAAgBF,SAASG,cAAc,uBAE7C,GADkBC,YAAaF,EAAcG,QAAQC,oBACtC,CACb,IAAMC,EAAM,2EAAAC,OACVN,EAAcG,QAAQI,oBADZ,4BAGNC,EAAaV,SAASG,cAAc,iCACtCO,GAAYA,EAAWC,mBAAmB,YAAaJ,GAGzC,IAAI3D,EAAYyC,IAAE,oBAAqBuB,IAAIC,KACnDnD,4CChBd,SAASoD,EAAQC,GACf,OAAOA,EAAUC,QAAQ,UAAY,GAAKD,EAAUC,QAAQ,QAAU,EAiBjE,SAASC,EAAgBF,GAC9B,IAAMG,EAVR,SAAkBH,GAChB,OAAOA,EAAUC,QAAQ,UAAY,IAAMF,EAAQC,GASzBI,CAASJ,IANrC,SAA0BA,GACxB,IAAMK,EAAQL,EAAUK,MAAM,8BAC9B,QAAOA,GAAQC,SAASD,EAAM,GAAI,IAIeE,CAAiBP,IAAc,GAC1EQ,EAAmBT,EAAQC,IAhBnC,SAAyBA,GACvB,IAAMK,EAAQL,EAAUK,MAAM,6BAC9B,QAAOA,GAAQC,SAASD,EAAM,GAAI,IAcaI,CAAgBT,IAAc,GACvEU,EACJV,EAAUC,QAAQ,UAAY,GAC9BD,EAAUC,QAAQ,UAAY,GAC9B,4BAA4BU,KAAKX,GACnC,OAAQG,GAAqBK,KAAsBE,EAGtC,SAASjD,IACtB,OAAImD,OAAOd,IACFe,QAAQC,QAAQF,OAAOd,KAI5BI,EADmC,oBAAda,UAA4BA,UAAUf,UAAY,KACxCH,KAAOA,IAAImB,SACrCH,QAAAC,UAAApD,KAAAuD,EAAAC,EAAA9E,KAAA,aAAgDsB,KAAK,kBAAMkD,OAAOd,MAGpEe,QAAQM,SAtCjBF,EAAAG,EAAAC,EAAA,sBAAA5D,gPCAqBO,aACnB,SAAAA,EAAYD,EAAWuD,gGAAatF,CAAAC,KAAA+B,GAClC/B,KAAK8B,UAAYA,EACjB9B,KAAK4C,QAAU5C,KAAK4C,QAAQzC,KAAKH,MACjCA,KAAKsF,cAA6C,WAA7BX,OAAOY,SAASC,SACrCxF,KAAKqF,YAAcA,2DAInB,GAAIrF,KAAK8B,YAAc6C,OAAOd,IAAI4B,WAAWC,aAAe1F,KAAKsF,cAC/D,MAAO,2FACF,GAAItF,KAAK8B,YAAc6C,OAAOd,IAAI4B,WAAWE,kBAAmB,CACrE,GAAyB,iBAArB3F,KAAKqF,YACP,MAAO,+CAET,GAAyB,aAArBrF,KAAKqF,YACP,MAAO,mDAGX,MAAO,8HCnBX,SAAAhD,GAgBA,IAMAuD,EANA/B,QAeAA,EAAAgC,aAAA,mCAYAhC,EAAAiC,cACAC,qBAAA,uBACAC,sBAAA,wBACAC,iBAAA,mBACAC,kBAAA,oBACAC,4BAAA,8BACAC,6BAAA,gCASAvC,EAAA4B,YACAY,GAAA,EACAC,YAAA,EACAZ,YAAA,EACAa,0BAAA,EACAZ,kBAAA,EACAa,QAAA,GAaA3C,EAAA4C,WAWA5C,EAAA6C,YAUA7C,EAAA8C,MAMA9C,EAAA+C,UAOA/C,EAAAgD,WAWAhD,EAAAiD,YAWAjD,EAAAkD,aAUAlD,EAAAmD,gBAYAnD,EAAAoD,iBAYApD,EAAAqD,cASArD,EAAAsD,wBAUAtD,EAAAuD,eAAA,SAAAC,GACA,uBAAAC,eAAAC,QAAA,CAIA,IAAAC,GACAC,KAAA5D,EAAAiC,aAAAG,iBACAlF,iBAEAuG,OAAAC,QAAAG,YAAA7D,EAAAgC,aAAA2B,EAAA,WACAF,OAAAC,QAAAI,UAOA9D,EAAA+D,eAAAP,GAJAxD,EAAAgE,sBAAAR,UAOKxD,EAAAiE,mBACLjE,EAAAkE,sBAAAV,GACKxD,EAAAmE,eACLnE,EAAAoE,YAAAZ,GAIAxD,EAAA+D,eAAAP,IAQAxD,EAAAiE,iBAAA,WACA,IAAA/D,EAAAe,UAAAf,UACA,UAAAA,EAAAC,QAAA,YACA,GAAAD,EAAAC,QAAA,YAOAH,EAAAmE,aAAA,WACA,OAAA3F,EAAA6F,QAAApD,UAAAqD,UAAA,6BAQAtE,EAAAgE,sBAAA,SAAAR,GACA,IAAAe,EAAAd,OAAAC,QAAAc,QAAAxE,EAAAgC,cACSyC,qBAAA,IACTC,WAAA,WACAlB,EAAA,IAAAxD,EAAA2E,0BAAAJ,KACK,IAQLvE,EAAAkE,sBAAA,SAAAV,GACAkB,WAAA,WACAlB,EAAA,IAAAxD,EAAA4E,4BACK,IAQL5E,EAAAoE,YAAA,SAAAZ,GACAkB,WAAA,WACAlB,EAAA,IAAAxD,EAAA6E,kBACK,IASL7E,EAAA2E,0BAAA,SAAAJ,GACApI,KAAA2I,MAAAP,GAUAvE,EAAA+E,mBACA,SAAAjI,EAAAkI,EAAAC,EAAAC,EAAAC,GACA,QAAAC,IAAArD,KAAA,KAGA,IADA,IAAA7E,KACAmI,EAAA,EAA2BA,EAAAJ,EAAAK,OAA2BD,IACtDnI,EAAAmI,IACAE,QAAAN,EAAAI,GAAAE,QACAP,YACAQ,UAAAP,EAAAI,GAAAG,UACA1I,SAGA,OACA8G,KAAA5D,EAAAiC,aAAAG,iBACAlF,eACAgI,iBACAO,UAAAN,GAIA,OACAvB,KAAA5D,EAAAiC,aAAAG,iBACAtF,QACAkI,YACAC,iBACAC,iBACAO,UAAAN,IAYAnF,EAAA0F,uBACA,SAAA5I,EAAAmI,EAAAjI,EAAAkI,EAAAC,GACA,QAAAC,IAAArD,KAAA,KAEA,QAAAsD,EAAA,EAA2BA,EAAArI,EAAAsI,OAA6BD,IACxDrI,EAAAqI,GAAAvI,QAEA,IAAAI,KACA,IAAAmI,EAAA,EAA2BA,EAAAJ,EAAAK,OAA2BD,IACtDnI,EAAAmI,IACAE,QAAAN,EAAAI,GAAAE,QACAP,UAAAhI,EAAA,GACAwI,UAAAP,EAAAI,GAAAG,UACA1I,SAGA,OACA8G,KAAA5D,EAAAiC,aAAAC,qBACAhF,eACAF,mBACAkI,iBACAO,UAAAN,GAIA,OACAvB,KAAA5D,EAAAiC,aAAAC,qBACApF,QACAE,mBACAiI,iBACAC,iBACAO,UAAAN,IASAnF,EAAA2E,0BAAAgB,UAAAC,YAAA,SAAA7G,GACA5C,KAAA2I,MAAAc,YAAA7G,IAUAiB,EAAA2E,0BAAAgB,UAAAvG,iBACA,SAAAyG,EAAAC,GACA,IAAAzH,EAAAwH,EAAAE,cACA,WAAA1H,GAAA,aAAAA,EACAlC,KAAA2I,MAAAkB,UAAAC,YAAA,SAAAlH,GAEA+G,GAAyBI,KAAAnH,MAGzBoH,QAAA3I,MAAA,qDASAwC,EAAA4E,0BAAA,WACAzI,KAAAiK,YAAA,EACAjK,KAAAkK,eAAA,MAOArG,EAAA4E,0BAAAe,UAAAC,YAAA,SAAA7G,GACA,IAAAuH,EACAtG,EAAA4E,0BAAA2B,iBACA,cAAUC,mBAAArI,KAAAC,UAAAW,IACV,OACAI,SAAAuC,SAAA4E,GAOAtG,EAAA4E,0BAAAe,UAAAc,YAAA,WACA,mCASAzG,EAAA4E,0BAAAe,UAAAvG,iBAAA,SAAAyG,EAAAC,GAEA,cADAD,EAAAE,cACA,CAIAjF,OAAA1B,iBACA,UAJAjD,KAIAuK,iBAAApK,KAJAH,KAIA2J,IAAA,QAEAK,QAAA3I,MAAA,mDASAwC,EAAA4E,0BAAAe,UAAAe,iBACA,SAAAlD,EAAAzE,GACA,IAAA4H,EAAAxI,KAAAyI,MAAA7H,EAAAmH,MAIAW,GAHAF,EAAA,UAEAA,EAAA,UACA,MACAA,EAAAG,eAAA,UACAD,EACA1I,KAAAyI,MAAAD,EAAA,OAGAnD,GAAkB0C,KAAAW,KAQlB7G,EAAA4E,0BAAA2B,iBACA,2EAOAvG,EAAA6E,gBAAA,aAMA7E,EAAA6E,gBAAAc,UAAAC,YAAA,SAAA7G,GACA,IAAAgI,EAAA5I,KAAAC,UAAAW,GACAiI,EAAA,cAAAC,UAAAF,GACArF,SAAAwF,QAAAF,IAOAhH,EAAA6E,gBAAAc,UAAAc,YAAA,WACA,yBAQAzG,EAAA6E,gBAAAc,UAAAvG,iBAAA,SAAAyG,EAAAC,GAEA,YADAD,EAAAE,eAEAI,QAAA3I,MAAA,yCASAwC,EAAA+D,eAAA,SAAAP,GAEA,IAAA2D,EAAA,sBAAAnH,EAAAgC,aACAoF,EAAAjI,SAAAkI,cAAA,UACAD,EAAAE,IAAAH,EAAA,kBACAC,EAAAG,aAAA,wBACApI,SAAAqI,KAAAC,YAAAL,GAEA,IAAAM,EAAA,IAAAC,eACAC,EAAA,SAAA7I,GACA,SAAAA,EAAAmH,MACAwB,EAAAG,MAAAC,oBAAA,UAAAF,GACApE,EAAAkE,EAAAG,QAEA1B,QAAA3I,MAAA,+CAGAkK,EAAAG,MAAAzI,iBAAA,UAAAwI,GACAF,EAAAG,MAAAhL,QAEAuK,EAAAhI,iBAAA,kBAEAgI,EAAAW,cAAAnC,YAAA,OAAAuB,GAAAO,EAAAM,WAWAhI,EAAAiI,sBAAA,GAOAjI,EAAA8E,MAAA,KAOA9E,EAAAkI,mBAOAlI,EAAAmI,YAAA,EAQAnI,EAAAoI,gBAOApI,EAAAqI,kBAAA,SAAA7E,GACAxD,EAAA8E,MACAtB,EAAAxD,EAAA8E,QAEA,GAAA9E,EAAAkI,gBAAA5C,QACAtF,EAAAuD,eAAA,SAAAgB,GAMA,IALAvE,EAAA8E,MAAAP,EACAvE,EAAA8E,MAAA1F,iBAAA,UAC+CY,EAAA,kBAG/CA,EAAAkI,gBAAA5C,QACAtF,EAAAkI,gBAAAI,OAAAtI,GAAA8E,SAGA9E,EAAAkI,gBAAAK,KAAA/E,KASAxD,EAAAwI,iBAAA,SAAAzJ,GACA,IAAAf,EAAAe,EAAAmH,KACAf,EAAAnH,EAAA,UACA,GAAAmH,GAAAnF,EAAAoI,aAAAjD,GAAA,CAIA,IAAAsD,EAAAzI,EAAAoI,aAAAjD,UACAnF,EAAAoI,aAAAjD,GACAsD,EAAAzK,EAAA,mBALAmI,QAAA3I,MAAA,8CAmBAwC,EAAA0I,KAAA,SAAA5L,EAAAkI,EAAAC,EAAAzB,EAAAmF,QACAvD,IAAArD,EAEA/B,EAAA4I,cACA,SAAA5K,GACA+D,OAAAqD,IAAApH,EAAA,iBAAAA,EAAA,eACAmI,QAAA0C,IAAA,6BAAA9G,GACA/B,EAAA8I,gBAAAhM,EAAAkI,EAAAC,EAAAzB,EAAAmF,KAIA3I,EAAA8I,gBAAAhM,EAAAkI,EAAAC,EAAAzB,EAAAmF,IAYA3I,EAAA8I,gBAAA,SAAAhM,EAAAkI,EAAAC,EAAAzB,EAAAmF,GACA3I,EAAAqI,kBAAA,SAAA9D,GACA,IAAAY,IAAAnF,EAAAmI,YACAnI,EAAAoI,aAAAjD,GAAA3B,EACA,IAAA0B,OAAA,IAAAyD,EACAA,EAAA3I,EAAAiI,sBACAc,EAAA/I,EAAA+E,mBAAAjI,EAAAkI,EAAAC,EAAAC,EAAAC,GACAZ,EAAAqB,YAAAmD,MAgBA/I,EAAApD,SAAA,SAAAE,EAAAE,EAAAiI,EAAAzB,EAAAmF,QACAvD,IAAArD,EAEA/B,EAAA4I,cACA,SAAA5K,GACA+D,OAAAqD,IAAApH,EAAA,iBAAAA,EAAA,eACAmI,QAAA0C,IAAA,6BAAA9G,GACA/B,EAAAgJ,oBAAAlM,EAAAE,EAAAiI,EACAzB,EAAAmF,KAIA3I,EAAAgJ,oBAAAlM,EAAAE,EAAAiI,EACAzB,EAAAmF,IAaA3I,EAAAgJ,oBAAA,SAAAlM,EAAAE,EAAAiI,EAAAzB,EAAAmF,GACA3I,EAAAqI,kBAAA,SAAA9D,GACA,IAAAY,IAAAnF,EAAAmI,YACAnI,EAAAoI,aAAAjD,GAAA3B,EACA,IAAA0B,OAAA,IAAAyD,EACAA,EAAA3I,EAAAiI,sBACAc,EAAA/I,EAAA0F,uBACA5I,EAAAmI,EAAAjI,EAAAkI,EAAAC,GACAZ,EAAAqB,YAAAmD,MAaA/I,EAAA4I,cAAA,SAAApF,EAAAmF,GACA3I,EAAAqI,kBAAA,SAAA9D,GAGA,GAAAA,EAAAkC,YAAA,CACA,IAAAwC,EACA,OAAA1E,EAAAkC,eACA,sBACA,gCACAwC,EAAA,IACA,MAEA,QACAA,EAAA,EAGAzF,GAAsBzB,eAAAkH,QAZtB,CAeA,IAAA9D,IAAAnF,EAAAmI,YACAnI,EAAAoI,aAAAjD,GAAA3B,EACA,IAAAuF,GACAnF,KAAA5D,EAAAiC,aAAAK,4BACA4C,oBAAA,IAAAyD,EACAA,EAAA3I,EAAAiI,sBACAxC,UAAAN,GAEAZ,EAAAqB,YAAAmD,OAIAjI,OAAAd,MAAAc,OAAAd","file":"pages.profiles.two_factor_auths.26ffb1c0.chunk.js","sourcesContent":["import $ from 'jquery';\nimport _ from 'underscore';\nimport importU2FLibrary from './util';\nimport U2FError from './error';\n\n// Register U2F (universal 2nd factor) devices for users to authenticate with.\n//\n// State Flow #1: setup -> in_progress -> registered -> POST to server\n// State Flow #2: setup -> in_progress -> error -> setup\nexport default class U2FRegister {\n  constructor(container, u2fParams) {\n    this.u2fUtils = null;\n    this.container = container;\n    this.renderNotSupported = this.renderNotSupported.bind(this);\n    this.renderRegistered = this.renderRegistered.bind(this);\n    this.renderError = this.renderError.bind(this);\n    this.renderInProgress = this.renderInProgress.bind(this);\n    this.renderSetup = this.renderSetup.bind(this);\n    this.renderTemplate = this.renderTemplate.bind(this);\n    this.register = this.register.bind(this);\n    this.start = this.start.bind(this);\n    this.appId = u2fParams.app_id;\n    this.registerRequests = u2fParams.register_requests;\n    this.signRequests = u2fParams.sign_requests;\n\n    this.templates = {\n      notSupported: '#js-register-u2f-not-supported',\n      setup: '#js-register-u2f-setup',\n      inProgress: '#js-register-u2f-in-progress',\n      error: '#js-register-u2f-error',\n      registered: '#js-register-u2f-registered',\n    };\n  }\n\n  start() {\n    return importU2FLibrary()\n      .then(utils => {\n        this.u2fUtils = utils;\n        this.renderSetup();\n      })\n      .catch(() => this.renderNotSupported());\n  }\n\n  register() {\n    return this.u2fUtils.register(\n      this.appId,\n      this.registerRequests,\n      this.signRequests,\n      response => {\n        if (response.errorCode) {\n          const error = new U2FError(response.errorCode, 'register');\n          return this.renderError(error);\n        }\n        return this.renderRegistered(JSON.stringify(response));\n      },\n      10,\n    );\n  }\n\n  renderTemplate(name, params) {\n    const templateString = $(this.templates[name]).html();\n    const template = _.template(templateString);\n    return this.container.html(template(params));\n  }\n\n  renderSetup() {\n    this.renderTemplate('setup');\n    return this.container.find('#js-setup-u2f-device').on('click', this.renderInProgress);\n  }\n\n  renderInProgress() {\n    this.renderTemplate('inProgress');\n    return this.register();\n  }\n\n  renderError(error) {\n    this.renderTemplate('error', {\n      error_message: error.message(),\n      error_code: error.errorCode,\n    });\n    return this.container.find('#js-u2f-try-again').on('click', this.renderSetup);\n  }\n\n  renderRegistered(deviceResponse) {\n    this.renderTemplate('registered');\n    // Prefer to do this instead of interpolating using Underscore templates\n    // because of JSON escaping issues.\n    return this.container.find('#js-device-response').val(deviceResponse);\n  }\n\n  renderNotSupported() {\n    return this.renderTemplate('notSupported');\n  }\n}\n","import $ from 'jquery';\nimport U2FRegister from '~/u2f/register';\nimport { parseBoolean } from '~/lib/utils/common_utils';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const twoFactorNode = document.querySelector('.js-two-factor-auth');\n  const skippable = parseBoolean(twoFactorNode.dataset.twoFactorSkippable);\n  if (skippable) {\n    const button = `<a class=\"btn btn-sm btn-warning float-right\" data-method=\"patch\" href=\"${\n      twoFactorNode.dataset.two_factor_skip_url\n    }\">Configure it later</a>`;\n    const flashAlert = document.querySelector('.flash-alert .container-fluid');\n    if (flashAlert) flashAlert.insertAdjacentHTML('beforeend', button);\n  }\n\n  const u2fRegister = new U2FRegister($('#js-register-u2f'), gon.u2f);\n  u2fRegister.start();\n});\n","function isOpera(userAgent) {\n  return userAgent.indexOf('Opera') >= 0 || userAgent.indexOf('OPR') >= 0;\n}\n\nfunction getOperaVersion(userAgent) {\n  const match = userAgent.match(/OPR[^0-9]*([0-9]+)[^0-9]+/);\n  return match ? parseInt(match[1], 10) : false;\n}\n\nfunction isChrome(userAgent) {\n  return userAgent.indexOf('Chrom') >= 0 && !isOpera(userAgent);\n}\n\nfunction getChromeVersion(userAgent) {\n  const match = userAgent.match(/Chrom(?:e|ium)\\/([0-9]+)\\./);\n  return match ? parseInt(match[1], 10) : false;\n}\n\nexport function canInjectU2fApi(userAgent) {\n  const isSupportedChrome = isChrome(userAgent) && getChromeVersion(userAgent) >= 41;\n  const isSupportedOpera = isOpera(userAgent) && getOperaVersion(userAgent) >= 40;\n  const isMobile =\n    userAgent.indexOf('droid') >= 0 ||\n    userAgent.indexOf('CriOS') >= 0 ||\n    /\\b(iPad|iPhone|iPod)(?=;)/.test(userAgent);\n  return (isSupportedChrome || isSupportedOpera) && !isMobile;\n}\n\nexport default function importU2FLibrary() {\n  if (window.u2f) {\n    return Promise.resolve(window.u2f);\n  }\n\n  const userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : '';\n  if (canInjectU2fApi(userAgent) || (gon && gon.test_env)) {\n    return import(/* webpackMode: \"eager\" */ 'vendor/u2f').then(() => window.u2f);\n  }\n\n  return Promise.reject();\n}\n","export default class U2FError {\n  constructor(errorCode, u2fFlowType) {\n    this.errorCode = errorCode;\n    this.message = this.message.bind(this);\n    this.httpsDisabled = window.location.protocol !== 'https:';\n    this.u2fFlowType = u2fFlowType;\n  }\n\n  message() {\n    if (this.errorCode === window.u2f.ErrorCodes.BAD_REQUEST && this.httpsDisabled) {\n      return 'U2F only works with HTTPS-enabled websites. Contact your administrator for more details.';\n    } else if (this.errorCode === window.u2f.ErrorCodes.DEVICE_INELIGIBLE) {\n      if (this.u2fFlowType === 'authenticate') {\n        return 'This device has not been registered with us.';\n      }\n      if (this.u2fFlowType === 'register') {\n        return 'This device has already been registered with us.';\n      }\n    }\n    return 'There was a problem communicating with your device.';\n  }\n}\n","//Copyright 2014-2015 Google Inc. All rights reserved.\n\n//Use of this source code is governed by a BSD-style\n//license that can be found in the LICENSE file or at\n//https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n'use strict';\n\n\n/**\n * Namespace for the U2F api.\n * @type {Object}\n */\nvar u2f = u2f || {};\n\n/**\n * FIDO U2F Javascript API Version\n * @number\n */\nvar js_api_version;\n\n/**\n * The U2F extension id\n * @const {string}\n */\n// The Chrome packaged app extension ID.\n// Uncomment this if you want to deploy a server instance that uses\n// the package Chrome app and does not require installing the U2F Chrome extension.\nu2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n// The U2F Chrome extension ID.\n// Uncomment this if you want to deploy a server instance that uses\n// the U2F Chrome extension to authenticate.\n// u2f.EXTENSION_ID = 'pfboblefjcgdjicmnffhdgionmgcdmne';\n\n\n/**\n * Message types for messsages to/from the extension\n * @const\n * @enum {string}\n */\nu2f.MessageTypes = {\n    'U2F_REGISTER_REQUEST': 'u2f_register_request',\n    'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n    'U2F_SIGN_REQUEST': 'u2f_sign_request',\n    'U2F_SIGN_RESPONSE': 'u2f_sign_response',\n    'U2F_GET_API_VERSION_REQUEST': 'u2f_get_api_version_request',\n    'U2F_GET_API_VERSION_RESPONSE': 'u2f_get_api_version_response'\n};\n\n\n/**\n * Response status codes\n * @const\n * @enum {number}\n */\nu2f.ErrorCodes = {\n    'OK': 0,\n    'OTHER_ERROR': 1,\n    'BAD_REQUEST': 2,\n    'CONFIGURATION_UNSUPPORTED': 3,\n    'DEVICE_INELIGIBLE': 4,\n    'TIMEOUT': 5\n};\n\n\n/**\n * A message for registration requests\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   appId: ?string,\n *   timeoutSeconds: ?number,\n *   requestId: ?number\n * }}\n */\nu2f.U2fRequest;\n\n\n/**\n * A message for registration responses\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n *   requestId: ?number\n * }}\n */\nu2f.U2fResponse;\n\n\n/**\n * An error object for responses\n * @typedef {{\n *   errorCode: u2f.ErrorCodes,\n *   errorMessage: ?string\n * }}\n */\nu2f.Error;\n\n/**\n * Data object for a single sign request.\n * @typedef {enum {BLUETOOTH_RADIO, BLUETOOTH_LOW_ENERGY, USB, NFC}}\n */\nu2f.Transport;\n\n\n/**\n * Data object for a single sign request.\n * @typedef {Array<u2f.Transport>}\n */\nu2f.Transports;\n\n/**\n * Data object for a single sign request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   keyHandle: string,\n *   appId: string\n * }}\n */\nu2f.SignRequest;\n\n\n/**\n * Data object for a sign response.\n * @typedef {{\n *   keyHandle: string,\n *   signatureData: string,\n *   clientData: string\n * }}\n */\nu2f.SignResponse;\n\n\n/**\n * Data object for a registration request.\n * @typedef {{\n *   version: string,\n *   challenge: string\n * }}\n */\nu2f.RegisterRequest;\n\n\n/**\n * Data object for a registration response.\n * @typedef {{\n *   version: string,\n *   keyHandle: string,\n *   transports: Transports,\n *   appId: string\n * }}\n */\nu2f.RegisterResponse;\n\n\n/**\n * Data object for a registered key.\n * @typedef {{\n *   version: string,\n *   keyHandle: string,\n *   transports: ?Transports,\n *   appId: ?string\n * }}\n */\nu2f.RegisteredKey;\n\n\n/**\n * Data object for a get API register response.\n * @typedef {{\n *   js_api_version: number\n * }}\n */\nu2f.GetJsApiVersionResponse;\n\n\n//Low level MessagePort API support\n\n/**\n * Sets up a MessagePort to the U2F extension using the\n * available mechanisms.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n */\nu2f.getMessagePort = function(callback) {\n    if (typeof chrome != 'undefined' && chrome.runtime) {\n        // The actual message here does not matter, but we need to get a reply\n        // for the callback to run. Thus, send an empty signature request\n        // in order to get a failure response.\n        var msg = {\n            type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n            signRequests: []\n        };\n        chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {\n            if (!chrome.runtime.lastError) {\n                // We are on a whitelisted origin and can talk directly\n                // with the extension.\n                u2f.getChromeRuntimePort_(callback);\n            } else {\n                // chrome.runtime was available, but we couldn't message\n                // the extension directly, use iframe\n                u2f.getIframePort_(callback);\n            }\n        });\n    } else if (u2f.isAndroidChrome_()) {\n        u2f.getAuthenticatorPort_(callback);\n    } else if (u2f.isIosChrome_()) {\n        u2f.getIosPort_(callback);\n    } else {\n        // chrome.runtime was not available at all, which is normal\n        // when this origin doesn't have access to any extensions.\n        u2f.getIframePort_(callback);\n    }\n};\n\n/**\n * Detect chrome running on android based on the browser's useragent.\n * @private\n */\nu2f.isAndroidChrome_ = function() {\n    var userAgent = navigator.userAgent;\n    return userAgent.indexOf('Chrome') != -1 &&\n        userAgent.indexOf('Android') != -1;\n};\n\n/**\n * Detect chrome running on iOS based on the browser's platform.\n * @private\n */\nu2f.isIosChrome_ = function() {\n    return $.inArray(navigator.platform, [\"iPhone\", \"iPad\", \"iPod\"]) > -1;\n};\n\n/**\n * Connects directly to the extension via chrome.runtime.connect.\n * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n * @private\n */\nu2f.getChromeRuntimePort_ = function(callback) {\n    var port = chrome.runtime.connect(u2f.EXTENSION_ID,\n        {'includeTlsChannelId': true});\n    setTimeout(function() {\n        callback(new u2f.WrappedChromeRuntimePort_(port));\n    }, 0);\n};\n\n/**\n * Return a 'port' abstraction to the Authenticator app.\n * @param {function(u2f.WrappedAuthenticatorPort_)} callback\n * @private\n */\nu2f.getAuthenticatorPort_ = function(callback) {\n    setTimeout(function() {\n        callback(new u2f.WrappedAuthenticatorPort_());\n    }, 0);\n};\n\n/**\n * Return a 'port' abstraction to the iOS client app.\n * @param {function(u2f.WrappedIosPort_)} callback\n * @private\n */\nu2f.getIosPort_ = function(callback) {\n    setTimeout(function() {\n        callback(new u2f.WrappedIosPort_());\n    }, 0);\n};\n\n/**\n * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n * @param {Port} port\n * @constructor\n * @private\n */\nu2f.WrappedChromeRuntimePort_ = function(port) {\n    this.port_ = port;\n};\n\n/**\n * Format and return a sign request compliant with the JS API version supported by the extension.\n * @param {Array<u2f.SignRequest>} signRequests\n * @param {number} timeoutSeconds\n * @param {number} reqId\n * @return {Object}\n */\nu2f.formatSignRequest_ =\n    function(appId, challenge, registeredKeys, timeoutSeconds, reqId) {\n        if (js_api_version === undefined || js_api_version < 1.1) {\n            // Adapt request to the 1.0 JS API\n            var signRequests = [];\n            for (var i = 0; i < registeredKeys.length; i++) {\n                signRequests[i] = {\n                    version: registeredKeys[i].version,\n                    challenge: challenge,\n                    keyHandle: registeredKeys[i].keyHandle,\n                    appId: appId\n                };\n            }\n            return {\n                type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n                signRequests: signRequests,\n                timeoutSeconds: timeoutSeconds,\n                requestId: reqId\n            };\n        }\n        // JS 1.1 API\n        return {\n            type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n            appId: appId,\n            challenge: challenge,\n            registeredKeys: registeredKeys,\n            timeoutSeconds: timeoutSeconds,\n            requestId: reqId\n        };\n    };\n\n/**\n * Format and return a register request compliant with the JS API version supported by the extension..\n * @param {Array<u2f.SignRequest>} signRequests\n * @param {Array<u2f.RegisterRequest>} signRequests\n * @param {number} timeoutSeconds\n * @param {number} reqId\n * @return {Object}\n */\nu2f.formatRegisterRequest_ =\n    function(appId, registeredKeys, registerRequests, timeoutSeconds, reqId) {\n        if (js_api_version === undefined || js_api_version < 1.1) {\n            // Adapt request to the 1.0 JS API\n            for (var i = 0; i < registerRequests.length; i++) {\n                registerRequests[i].appId = appId;\n            }\n            var signRequests = [];\n            for (var i = 0; i < registeredKeys.length; i++) {\n                signRequests[i] = {\n                    version: registeredKeys[i].version,\n                    challenge: registerRequests[0],\n                    keyHandle: registeredKeys[i].keyHandle,\n                    appId: appId\n                };\n            }\n            return {\n                type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n                signRequests: signRequests,\n                registerRequests: registerRequests,\n                timeoutSeconds: timeoutSeconds,\n                requestId: reqId\n            };\n        }\n        // JS 1.1 API\n        return {\n            type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n            appId: appId,\n            registerRequests: registerRequests,\n            registeredKeys: registeredKeys,\n            timeoutSeconds: timeoutSeconds,\n            requestId: reqId\n        };\n    };\n\n\n/**\n * Posts a message on the underlying channel.\n * @param {Object} message\n */\nu2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {\n    this.port_.postMessage(message);\n};\n\n\n/**\n * Emulates the HTML 5 addEventListener interface. Works only for the\n * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedChromeRuntimePort_.prototype.addEventListener =\n    function(eventName, handler) {\n        var name = eventName.toLowerCase();\n        if (name == 'message' || name == 'onmessage') {\n            this.port_.onMessage.addListener(function(message) {\n                // Emulate a minimal MessageEvent object\n                handler({'data': message});\n            });\n        } else {\n            console.error('WrappedChromeRuntimePort only supports onMessage');\n        }\n    };\n\n/**\n * Wrap the Authenticator app with a MessagePort interface.\n * @constructor\n * @private\n */\nu2f.WrappedAuthenticatorPort_ = function() {\n    this.requestId_ = -1;\n    this.requestObject_ = null;\n}\n\n/**\n * Launch the Authenticator intent.\n * @param {Object} message\n */\nu2f.WrappedAuthenticatorPort_.prototype.postMessage = function(message) {\n    var intentUrl =\n        u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ +\n        ';S.request=' + encodeURIComponent(JSON.stringify(message)) +\n        ';end';\n    document.location = intentUrl;\n};\n\n/**\n * Tells what type of port this is.\n * @return {String} port type\n */\nu2f.WrappedAuthenticatorPort_.prototype.getPortType = function() {\n    return \"WrappedAuthenticatorPort_\";\n};\n\n\n/**\n * Emulates the HTML 5 addEventListener interface.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedAuthenticatorPort_.prototype.addEventListener = function(eventName, handler) {\n    var name = eventName.toLowerCase();\n    if (name == 'message') {\n        var self = this;\n        /* Register a callback to that executes when\n         * chrome injects the response. */\n        window.addEventListener(\n            'message', self.onRequestUpdate_.bind(self, handler), false);\n    } else {\n        console.error('WrappedAuthenticatorPort only supports message');\n    }\n};\n\n/**\n * Callback invoked  when a response is received from the Authenticator.\n * @param function({data: Object}) callback\n * @param {Object} message message Object\n */\nu2f.WrappedAuthenticatorPort_.prototype.onRequestUpdate_ =\n    function(callback, message) {\n        var messageObject = JSON.parse(message.data);\n        var intentUrl = messageObject['intentURL'];\n\n        var errorCode = messageObject['errorCode'];\n        var responseObject = null;\n        if (messageObject.hasOwnProperty('data')) {\n            responseObject = /** @type {Object} */ (\n                JSON.parse(messageObject['data']));\n        }\n\n        callback({'data': responseObject});\n    };\n\n/**\n * Base URL for intents to Authenticator.\n * @const\n * @private\n */\nu2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ =\n    'intent:#Intent;action=com.google.android.apps.authenticator.AUTHENTICATE';\n\n/**\n * Wrap the iOS client app with a MessagePort interface.\n * @constructor\n * @private\n */\nu2f.WrappedIosPort_ = function() {};\n\n/**\n * Launch the iOS client app request\n * @param {Object} message\n */\nu2f.WrappedIosPort_.prototype.postMessage = function(message) {\n    var str = JSON.stringify(message);\n    var url = \"u2f://auth?\" + encodeURI(str);\n    location.replace(url);\n};\n\n/**\n * Tells what type of port this is.\n * @return {String} port type\n */\nu2f.WrappedIosPort_.prototype.getPortType = function() {\n    return \"WrappedIosPort_\";\n};\n\n/**\n * Emulates the HTML 5 addEventListener interface.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedIosPort_.prototype.addEventListener = function(eventName, handler) {\n    var name = eventName.toLowerCase();\n    if (name !== 'message') {\n        console.error('WrappedIosPort only supports message');\n    }\n};\n\n/**\n * Sets up an embedded trampoline iframe, sourced from the extension.\n * @param {function(MessagePort)} callback\n * @private\n */\nu2f.getIframePort_ = function(callback) {\n    // Create the iframe\n    var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n    var iframe = document.createElement('iframe');\n    iframe.src = iframeOrigin + '/u2f-comms.html';\n    iframe.setAttribute('style', 'display:none');\n    document.body.appendChild(iframe);\n\n    var channel = new MessageChannel();\n    var ready = function(message) {\n        if (message.data == 'ready') {\n            channel.port1.removeEventListener('message', ready);\n            callback(channel.port1);\n        } else {\n            console.error('First event on iframe port was not \"ready\"');\n        }\n    };\n    channel.port1.addEventListener('message', ready);\n    channel.port1.start();\n\n    iframe.addEventListener('load', function() {\n        // Deliver the port to the iframe and initialize\n        iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n    });\n};\n\n\n//High-level JS API\n\n/**\n * Default extension response timeout in seconds.\n * @const\n */\nu2f.EXTENSION_TIMEOUT_SEC = 30;\n\n/**\n * A singleton instance for a MessagePort to the extension.\n * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n * @private\n */\nu2f.port_ = null;\n\n/**\n * Callbacks waiting for a port\n * @type {Array<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n * @private\n */\nu2f.waitingForPort_ = [];\n\n/**\n * A counter for requestIds.\n * @type {number}\n * @private\n */\nu2f.reqCounter_ = 0;\n\n/**\n * A map from requestIds to client callbacks\n * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n *                       |function((u2f.Error|u2f.SignResponse)))>}\n * @private\n */\nu2f.callbackMap_ = {};\n\n/**\n * Creates or retrieves the MessagePort singleton to use.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n * @private\n */\nu2f.getPortSingleton_ = function(callback) {\n    if (u2f.port_) {\n        callback(u2f.port_);\n    } else {\n        if (u2f.waitingForPort_.length == 0) {\n            u2f.getMessagePort(function(port) {\n                u2f.port_ = port;\n                u2f.port_.addEventListener('message',\n                    /** @type {function(Event)} */ (u2f.responseHandler_));\n\n                // Careful, here be async callbacks. Maybe.\n                while (u2f.waitingForPort_.length)\n                    u2f.waitingForPort_.shift()(u2f.port_);\n            });\n        }\n        u2f.waitingForPort_.push(callback);\n    }\n};\n\n/**\n * Handles response messages from the extension.\n * @param {MessageEvent.<u2f.Response>} message\n * @private\n */\nu2f.responseHandler_ = function(message) {\n    var response = message.data;\n    var reqId = response['requestId'];\n    if (!reqId || !u2f.callbackMap_[reqId]) {\n        console.error('Unknown or missing requestId in response.');\n        return;\n    }\n    var cb = u2f.callbackMap_[reqId];\n    delete u2f.callbackMap_[reqId];\n    cb(response['responseData']);\n};\n\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * If the JS API version supported by the extension is unknown, it first sends a\n * message to the extension to find out the supported API version and then it sends\n * the sign request.\n * @param {string=} appId\n * @param {string=} challenge\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sign = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n    if (js_api_version === undefined) {\n        // Send a message to get the extension to JS API version, then send the actual sign request.\n        u2f.getApiVersion(\n            function (response) {\n                js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];\n                console.log(\"Extension JS API Version: \", js_api_version);\n                u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n            });\n    } else {\n        // We know the JS API version. Send the actual sign request in the supported API version.\n        u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n    }\n};\n\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * @param {string=} appId\n * @param {string=} challenge\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sendSignRequest = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function(port) {\n        var reqId = ++u2f.reqCounter_;\n        u2f.callbackMap_[reqId] = callback;\n        var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?\n            opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);\n        var req = u2f.formatSignRequest_(appId, challenge, registeredKeys, timeoutSeconds, reqId);\n        port.postMessage(req);\n    });\n};\n\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * If the JS API version supported by the extension is unknown, it first sends a\n * message to the extension to find out the supported API version and then it sends\n * the register request.\n * @param {string=} appId\n * @param {Array<u2f.RegisterRequest>} registerRequests\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.register = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n    if (js_api_version === undefined) {\n        // Send a message to get the extension to JS API version, then send the actual register request.\n        u2f.getApiVersion(\n            function (response) {\n                js_api_version = response['js_api_version'] === undefined ? 0: response['js_api_version'];\n                console.log(\"Extension JS API Version: \", js_api_version);\n                u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,\n                    callback, opt_timeoutSeconds);\n            });\n    } else {\n        // We know the JS API version. Send the actual register request in the supported API version.\n        u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,\n            callback, opt_timeoutSeconds);\n    }\n};\n\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * @param {string=} appId\n * @param {Array<u2f.RegisterRequest>} registerRequests\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sendRegisterRequest = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function(port) {\n        var reqId = ++u2f.reqCounter_;\n        u2f.callbackMap_[reqId] = callback;\n        var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?\n            opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);\n        var req = u2f.formatRegisterRequest_(\n            appId, registeredKeys, registerRequests, timeoutSeconds, reqId);\n        port.postMessage(req);\n    });\n};\n\n\n/**\n * Dispatches a message to the extension to find out the supported\n * JS API version.\n * If the user is on a mobile phone and is thus using Google Authenticator instead\n * of the Chrome extension, don't send the request and simply return 0.\n * @param {function((u2f.Error|u2f.GetJsApiVersionResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.getApiVersion = function(callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function(port) {\n        // If we are using Android Google Authenticator or iOS client app,\n        // do not fire an intent to ask which JS API version to use.\n        if (port.getPortType) {\n            var apiVersion;\n            switch (port.getPortType()) {\n                case 'WrappedIosPort_':\n                case 'WrappedAuthenticatorPort_':\n                    apiVersion = 1.1;\n                    break;\n\n                default:\n                    apiVersion = 0;\n                    break;\n            }\n            callback({ 'js_api_version': apiVersion });\n            return;\n        }\n        var reqId = ++u2f.reqCounter_;\n        u2f.callbackMap_[reqId] = callback;\n        var req = {\n            type: u2f.MessageTypes.U2F_GET_API_VERSION_REQUEST,\n            timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n                opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n            requestId: reqId\n        };\n        port.postMessage(req);\n    });\n};\n\nwindow.u2f || (window.u2f = u2f);\n"],"sourceRoot":""}